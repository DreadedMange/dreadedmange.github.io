<!DOCTYPE html>
<!-- Use the poker.css style sheet -->
<!-- This html page will allow a user to practice identifying their Omaha poker hand-->
<!-- The user will be presented with a board and hole cards and will be asked to identify their best hand-->
<html lang="en">

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z369DVSQ0F"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-Z369DVSQ0F');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omaha Hold'em Hand</title>
    <link rel="stylesheet" href="poker.css" />
    <script src="js/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="js/gpt-poker-min.js?v=1.0.1"></script>

    <script>
        /*import { createDeck, shuffleDeck, scoreHand, getHandDescription, bestOmahaHand, categories, getSuitCharColor } from './gpt-poker.js';*/
        function createConfetti() {
            // You can adjust the confetti settings by passing an options object to the confetti() function
            const confettiSettings = {
                particleCount: 100,
                spread: 70,
                origin: { y: 0.6 }
            };
            confetti(confettiSettings);
        }

        function createPerformanceChart(handCategoryTable) {
            const ctx = document.getElementById('performanceChart').getContext('2d');

            const labels = Object.keys(handCategoryTable);
            const correctData = labels.map((label) => handCategoryTable[label].correct);
            const incorrectData = labels.map((label) => handCategoryTable[label].incorrect);

            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Correct',
                            data: correctData,
                            backgroundColor: 'rgba(75, 192, 192, 0.5)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1,
                        },
                        {
                            label: 'Incorrect',
                            data: incorrectData,
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                        },
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                    },
                },
            });

            return chart;
        }



        // declare deck, board, hole, and bestHand variables
        let OmahaBoard, OmahaHole, OmahaBestHand;

        // initialize a table to keep track of the number of correct and incorrect guesses,
        // by hand category
        // It'll be stored in local storage so we can keep track of the user's performance
        let handCategoryTable = {
            'high card': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
            'pair': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
            'two pair': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
            'three of a kind': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
            'straight': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
            'flush': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
            'full house': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
            'four of a kind': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
            'straight flush': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 }
        };


        // declare a variable to keep track of the performance chart
        let performanceChart;

        // Create a function updateTable(bCorrect, omahaHand) that will update the table with the number of correct and incorrect guesses
        function updateTable(bCorrect, omahaHand, timeSpent) {
            const score = scoreHand(omahaHand);
            const handCategory = categories[score.category];

            // get the stored table from local storage
            const storedTable = localStorage.getItem('handCategoryTable');
            if (storedTable) {
                // if there is a stored table, use it
                handCategoryTable = JSON.parse(storedTable);
            }

            // update the table
            if (bCorrect) {
                handCategoryTable[handCategory].correct++;
                handCategoryTable[handCategory].secondsCorrect += timeSpent;
            } else {
                handCategoryTable[handCategory].incorrect++;
                handCategoryTable[handCategory].secondsIncorrect += timeSpent;
            }



            // handCategoryTable has been updated. Now save it to local storage.
            localStorage.setItem('handCategoryTable', JSON.stringify(handCategoryTable));
            updateGraphAndTable(handCategoryTable);
        }
        function updateGraphAndTable(handCategoryTable) {
            // Calculate the total number of correct and incorrect guesses
            var totalCorrect = Object.keys(handCategoryTable).reduce((total, handCategory) => {
                return total + handCategoryTable[handCategory].correct;
            }, 0);

            var totalIncorrect = Object.keys(handCategoryTable).reduce((total, handCategory) => {
                return total + handCategoryTable[handCategory].incorrect;
            }, 0);

            if (totalCorrect > 0 || totalIncorrect > 0) {
                var totalPercentCorrect = (totalCorrect / (totalCorrect + totalIncorrect)) * 100;
            } else {
                var totalPercentCorrect = 0;
            }
            // calculate total time spent on correct and incorrect guesses
            var totalSecondsCorrect = Object.keys(handCategoryTable).reduce((total, handCategory) => {
                return total + handCategoryTable[handCategory].secondsCorrect;
            }, 0);
            var totalSecondsIncorrect = Object.keys(handCategoryTable).reduce((total, handCategory) => {
                return total + handCategoryTable[handCategory].secondsIncorrect;
            }, 0);
            // calculate average time spent on correct and incorrect guesses
            if (totalCorrect > 0) {
                var averageSecondsCorrect = totalSecondsCorrect / totalCorrect;
            } else {
                var averageSecondsCorrect = 0;
            }
            if (totalIncorrect > 0) {
                var averageSecondsIncorrect = totalSecondsIncorrect / totalIncorrect;
            } else {
                var averageSecondsIncorrect = 0;
            }

            // Update the table in the DOM
            const table = document.getElementById('hand_category_table');
            table.innerHTML = `
    <tr>
      <th>Hand Category</th>
      <th>Correct</th>
      <th>Incorrect</th>
      <th>Percent Correct</th>
      <th>Total Time Correct</th>
        <th>Average Time Correct (s)</th>
        <th>Total Time Incorrect</th>
        <th>Average Time Incorrect (s)</th>
    </tr>
    ${Object.keys(handCategoryTable).map((handCategory) => {
                const correct = handCategoryTable[handCategory].correct;
                const incorrect = handCategoryTable[handCategory].incorrect;
                const total = correct + incorrect;
                const percentCorrect = total > 0 ? ((correct / total) * 100).toFixed(0) : '-';
                const minutesCorrect = Math.floor(handCategoryTable[handCategory].secondsCorrect / 60);
                const secondsCorrect = handCategoryTable[handCategory].secondsCorrect % 60;
                const minutesIncorrect = Math.floor(handCategoryTable[handCategory].secondsIncorrect / 60);
                const secondsIncorrect = handCategoryTable[handCategory].secondsIncorrect % 60;
                const averageSecondsCorrect = handCategoryTable[handCategory].secondsCorrect / correct;
                const averageSecondsIncorrect = handCategoryTable[handCategory].secondsIncorrect / incorrect;
                return `
        <tr>
          <td>${handCategory}</td>
          <td>${correct}</td>
          <td>${incorrect}</td>
          <td>${percentCorrect}%</td>
            <td>${minutesCorrect}:${secondsCorrect < 10 ? '0' : ''}${secondsCorrect}</td>
            <td>${isNaN(averageSecondsCorrect) ? '-' : averageSecondsCorrect.toFixed(1)}</td>
            <td>${minutesIncorrect}:${secondsIncorrect < 10 ? '0' : ''}${secondsIncorrect}</td>
            <td>${isNaN(averageSecondsIncorrect) ? '-' : averageSecondsIncorrect.toFixed(1)}</td>

        </tr>
      `;
            }).join('')}
    <tr>
      <td>Total</td>
      <td>${Object.keys(handCategoryTable).reduce((total, handCategory) => {
                return total + handCategoryTable[handCategory].correct;
            }, 0)}</td>
      <td>${Object.keys(handCategoryTable).reduce((total, handCategory) => {
                return total + handCategoryTable[handCategory].incorrect;
            }, 0)}</td>
            <td>${totalPercentCorrect.toFixed(0)}%</td>
            <td>${Math.floor(totalSecondsCorrect / 60)}m:${(totalSecondsCorrect % 60) < 10 ? '0' : ''}${(totalSecondsCorrect % 60)}s</td>
            <td>${averageSecondsCorrect.toFixed(1)}</td>
            <td>${Math.floor(totalSecondsIncorrect / 60)}m:${(totalSecondsIncorrect % 60) < 10 ? '0' : ''}${(totalSecondsIncorrect % 60)}s</td>
            <td>${averageSecondsIncorrect.toFixed(1)}</td>
    </tr>
  `;
            // Update the performance chart
            if (!performanceChart) {
                performanceChart = createPerformanceChart(handCategoryTable);
            } else {
                const labels = Object.keys(handCategoryTable);
                performanceChart.data.labels = labels;
                performanceChart.data.datasets[0].data = labels.map((label) => handCategoryTable[label].correct);
                performanceChart.data.datasets[1].data = labels.map((label) => handCategoryTable[label].incorrect);
                performanceChart.update();
            }
        } // end updateGraphAndTable




        // render cards to the DOM
        function renderCards(cards, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            cards.forEach((card) => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card');
                // Set the data-rank and data-suit attributes
                cardDiv.dataset.rank = card.rank;
                cardDiv.dataset.suit = card.suit;
                cardDiv.innerHTML = `
                    <div class="card-rank">${card.rank}</div>
                    <div class="card-suit">${getSuitCharColor(card.suit)}</div>
                `;
                container.appendChild(cardDiv);
            });
        }

        // Takes a poker hand and a container id and renders a text description
        // of the hand and it's score to the DOM
        function renderHandScore(hand, openingText, containerId) {
            const container = document.getElementById(containerId);
            const handDescription = getHandDescription(hand);
            container.innerHTML = `
                <div>${openingText} ${handDescription}</div>
            `;
        }

        function drawOmahaHand() {
            const deck = shuffleDeck(createDeck());
            OmahaBoard = deck.slice(0, 5);
            OmahaHole = deck.slice(5, 9);

            // for testing set the board and hole cards to a known hand
            /*
            OmahaBoard = parseHand('4h7cQcQd4d');
            OmahaHole = parseHand('5c4s4c5s');
            */
            renderCards(OmahaBoard, 'omaha_board');
            renderCards(OmahaHole, 'omaha_hole');

            // We need to clear the best hand left over from prior iteration
            const omaha_score_true = document.getElementById('omaha_score_true');
            omaha_score_true.innerHTML = `2. Click Confirm`;
            const omaha_score_user = document.getElementById('omaha_score_user');
            omaha_score_user.innerHTML = `1. Pick your cards`;
        }


        // Render cards with class adjusted to show correct or incorrect selection
        function renderAlternateCards(OmahaBestHand) {
            const hole = document.getElementById('omaha_hole');
            const board = document.getElementById('omaha_board');
            const holeCards = hole.getElementsByClassName('card');
            const boardCards = board.getElementsByClassName('card');

            // Helper function to check if a card is in the OmahaBestHand array
            const isCardInBestHand = (card) => {
                return OmahaBestHand.some(
                    (bestHandCard) => bestHandCard.rank === card.rank && bestHandCard.suit === card.suit
                );
            };

            // Update the hole cards
            for (const card of holeCards) {
                const cardData = { rank: card.dataset.rank, suit: card.dataset.suit };
                if (card.classList.contains('selected')) {
                    card.classList.remove('selected');
                    if (!isCardInBestHand(cardData)) {
                        card.classList.add('selected-wrong');
                    } else {
                        card.classList.add('selected-right');
                    }
                } else if (isCardInBestHand(cardData)) {
                    card.classList.add('should-have-selected');
                } else {
                    card.classList.add('unselected-right')
                }
            }

            // Update the board cards
            for (const card of boardCards) {
                const cardData = { rank: card.dataset.rank, suit: card.dataset.suit };
                if (card.classList.contains('selected')) {
                    card.classList.remove('selected');
                    if (!isCardInBestHand(cardData)) {
                        card.classList.add('selected-wrong');
                    } else {
                        card.classList.add('selected-right');
                    }
                } else if (isCardInBestHand(cardData)) {
                    card.classList.add('should-have-selected');
                } else {
                    card.classList.add('unselected-right')
                }
            }
        }

        // determine if the user has selected the correct cards
        function allSelectedCardsAreCorrect(OmahaBestHand) {
            const hole = document.getElementById('omaha_hole');
            const board = document.getElementById('omaha_board');
            const holeSelectedCards = hole.getElementsByClassName('card selected');
            const boardSelectedCards = board.getElementsByClassName('card selected');

            if (holeSelectedCards.length !== 2 || boardSelectedCards.length !== 3) {
                return false;
            }

            const selectedCards = [...holeSelectedCards, ...boardSelectedCards];

            return selectedCards.every((selectedCard) => {
                const cardData = { rank: selectedCard.dataset.rank, suit: selectedCard.dataset.suit };
                return OmahaBestHand.some(
                    (bestHandCard) => bestHandCard.rank === cardData.rank && bestHandCard.suit === cardData.suit
                );
            });
        }


        // Add event listeners to the buttons

        // We'll use the event delegation pattern to add a single event listener to the board
        // and then check to see if the click was on a card
        document.addEventListener('DOMContentLoaded', () => {
            // Get the containers for both the hole and the board
            const hole = document.getElementById('omaha_hole');
            const board = document.getElementById('omaha_board');
            const omahaConfirmBtn = document.getElementById('omahaConfirmBtn');
            const omahaDrawBtn = document.getElementById('omahaDrawBtn');
            const ResetStats = document.getElementById('ResetStats');

            // Card selection flag
            let cardSelectionEnabled = true;

            // Timer variables
            totalSeconds = 0;

            // Function to update the button state
            const updateButtonState = () => {
                const selectedHoleCards = hole.getElementsByClassName('selected').length;
                const selectedBoardCards = board.getElementsByClassName('selected').length;

                omahaConfirmBtn.disabled = selectedHoleCards !== 2 || selectedBoardCards !== 3;
            };

            // Function to reset local storage when resetStats button is pressed
            ResetStats.addEventListener('click', () => {
                localStorage.removeItem('handCategoryTable');
                handCategoryTable = {
                    'high card': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
                    'pair': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
                    'two pair': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
                    'three of a kind': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
                    'straight': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
                    'flush': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
                    'full house': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
                    'four of a kind': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 },
                    'straight flush': { correct: 0, incorrect: 0, secondsCorrect: 0, secondsIncorrect: 0 }
                };
                updateGraphAndTable(handCategoryTable);
            });

            // Create a function to handle card clicks
            const handleCardClick = (event) => {
                if (!cardSelectionEnabled) {
                    return;
                }

                // Check to see if the click was on a card
                if (event.target.classList.contains('card')) {
                    // Get the container of the clicked card
                    const container = event.target.parentElement;

                    // Count the number of selected cards in the container
                    const selectedCards = container.getElementsByClassName('selected').length;

                    // Check if the card is already selected
                    const isSelected = event.target.classList.contains('selected');

                    // Define the maximum number of allowed selected cards for each container
                    const maxSelectedCards = container === hole ? 2 : 3;

                    // Toggle the selected class on the card if the constraints are met
                    if (isSelected || selectedCards < maxSelectedCards) {
                        event.target.classList.toggle('selected');
                    }

                    // Update the button state after each click
                    updateButtonState();
                }
            };

            // Add the click event listeners to both the hole and the board
            hole.addEventListener('click', handleCardClick);
            board.addEventListener('click', handleCardClick);

            // Add a click event listener to the confirm button
            // Disable card selection when the confirm button is clicked
            omahaConfirmBtn.addEventListener('click', () => {
                cardSelectionEnabled = false;
                omahaConfirmBtn.disabled = true; // disable when the button is clicked
                omahaDrawBtn.disabled = false; // enable the draw button

                // timer code
                clearInterval(timerVar);
                const elapsedTime = totalSeconds;

                // create a string representation of the time
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                const timeString = `${minutes < 10 ? '0' : ''}${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;

                // now that the user has confirmed their selection, 
                // we can render the hand and score
                const selectedHoleCards = hole.getElementsByClassName('selected');
                const selectedBoardCards = board.getElementsByClassName('selected');

                // find the best hand from the board and hole cards
                OmahaBestHand = bestOmahaHand(OmahaBoard, OmahaHole);
                const selectedHand = [...selectedHoleCards, ...selectedBoardCards].map((card) => {
                    return {
                        rank: card.dataset.rank,
                        suit: card.dataset.suit,
                    };
                });
                const scoreSelectedHand = scoreHand(selectedHand);
                const scoreOmahaBestHand = scoreHand(OmahaBestHand);

                // make some confetti if the user chose correctly
                let picked_correct;
                let pickText;
                if (scoreSelectedHand.score === scoreOmahaBestHand.score) {
                    createConfetti();
                    // set a variable to indicate that the user has won
                    // this will be used to keep track of correct and incorrect answers
                    picked_correct = true;
                    // set the best hand to the selected hand since 
                    // the user has selected the correct hand
                    // Note there may be more than one correct answer so 
                    // we'll use the one the user chose since it has the same
                    // score as the best hand our algorithm found
                    OmahaBestHand = selectedHand;
                    pickText = `Correct!:`;
                } else {
                    picked_correct = false;
                    pickText = `Wrong!:`;
                }

                // Update table with correct/incorrect answer, as well as the category of hand
                updateTable(picked_correct, OmahaBestHand, elapsedTime);

                // render the selected cards to indicate correct or incorrect selection
                renderAlternateCards(OmahaBestHand);

                renderHandScore(selectedHand, pickText, 'omaha_score_user');
                if (!picked_correct) {
                    renderHandScore(OmahaBestHand, 'Best Hand:', 'omaha_score_true');
                } else {
                    const container = document.getElementById('omaha_score_true');
                    // We need to insert a line of html so the rest of the page doesn't shift

                    container.innerHTML = ``;
                }
                handCategory = categories[scoreOmahaBestHand.category];
                // make a string of handCategor plus 'correct' or 'incorrect'
                handCategory = 'Omaha_' + handCategory + '_' + (picked_correct ? 'correct' : 'incorrect');
                // add google analytics event to record the time spent on the hand, and whether the user was correct, and the hand category
                gtag('event', 'identify_hand', {
                    'event_category': 'omaha_hand',
                    'event_label': handCategory,
                    'value': elapsedTime,
                });


            });

            // Enable card selection when the draw button is clicked
            omahaDrawBtn.addEventListener('click', () => {
                cardSelectionEnabled = true;
                omahaDrawBtn.disabled = true; // disable when the button is clicked
                drawOmahaHand();
                updateButtonState();
                // Stop the timer - shouldn't be necessary but just in case
                clearInterval(timerVar);

                // Reset the timer
                totalSeconds = 0;
                document.getElementById("minutes").innerHTML = '00';
                document.getElementById("seconds").innerHTML = '00';

                // Restart the timer
                timerVar = setInterval(countTimer, 1000);
            });
            const coll = document.querySelector('.collapsible');

            coll.addEventListener('click', function () {
                this.classList.toggle('active');
                const content = this.nextElementSibling;

                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + 'px';
                }
            });

            // Pause the timer when the page is hidden
            document.addEventListener('visibilitychange', function () {
                if (document.visibilityState === 'hidden') {
                    clearInterval(timerVar);
                } else {
                    timerVar = setInterval(countTimer, 1000);
                }
            });
            // draw first hand when the page loads
            drawOmahaHand();
            updateButtonState();
            omahaDrawBtn.disabled = true;

            // update the results graph if there are results stored in local storage
            const storedTable = localStorage.getItem('handCategoryTable');
            if (storedTable) {
                // check that secondsCorrect or secondsIncorrect exists for at least one hand category 
                // and if not, delete thte table from localStorage
                const storedTableParsed = JSON.parse(storedTable);
                const secondsCorrectExists = Object.keys(storedTableParsed).some((handCategory) => {
                    return storedTableParsed[handCategory].secondsCorrect > 0;
                });
                const secondsIncorrectExists = Object.keys(storedTableParsed).some((handCategory) => {
                    return storedTableParsed[handCategory].secondsIncorrect > 0;
                });
                if (!secondsCorrectExists && !secondsIncorrectExists) {
                    localStorage.removeItem('handCategoryTable');
                } else {
                    handCategoryTable = JSON.parse(storedTable);
                    updateGraphAndTable(handCategoryTable);
                }
            }

        });

    </script>
</head>

<body>
    <h1>Omaha Hand</h1>
    <button class="collapsible">Show/Hide Hints</button>
    <div class="content">
        <p>Here are some hints for identifying Omaha poker hands, sorted from highest to lowest rank:</p>
        <p>In Omaha, you must use exactly three cards from the shared community cards (the "board")
            and exactly two cards from your own hand (the "hole") to form your best five-card poker hand. The following
            strategy
            may be helpful - with this approach you can stop looking as soon as you find a match.</p>
        <ol>
            <li>Check for straight flush possibilities:
                <ul>
                    <li>Arrange the community cards mentally from highest to lowest.</li>
                    <li>Search for three community cards that are in a 5-card span (example J-8-7) and of the same suit.
                    </li>
                    <li>If found, see if you have two hole cards of the same suit that can complete the straight flush.
                    </li>
                </ul>
            </li>
            <li>Check for four of a kind:
                <ul>
                    <li>Note that four of a kind is only possible if there is a pair or three of a kind on the board.
                    </li>
                    <li>See if you can turn the pair or three of a kind on the board into four of a kind with your hole
                        cards.</li>
                </ul>
            </li>
            <li>Check for a full house:
                <ul>
                    <li>Identify if there's a pair or three of a kind in the community cards.</li>
                    <li>Verify if you can form a full house using your two hole cards.</li>
                </ul>
            </li>
            <li>Check for flush possibilities:
                <ul>
                    <li>Look for at least three community cards of the same suit.</li>
                    <li>If there are at least three of one suit, check if you have two hole cards of the same suit to
                        complete the flush.</li>
                </ul>
            </li>
            <li>Check for straights:
                <ul>
                    <li>Look for at least three community cards that are within a five-card span (e.g., 7-6-4 or J-T-8).
                    </li>
                    <li>If found, note the missing cards and check your hole cards for two cards that can fill the gaps
                        to complete a straight.</li>
                    <li>Be aware that if there are more than three in a 5-card span on the board, you can only use 3
                        still. In this situation,
                        hole cards that pair the board can be very useful!</li>
                </ul>
            </li>
            <li>Check for three of a kind:
                <ul>
                    <li>Identify if there are any two identical cards on the board, or a pair in the hole that matches a
                        board card to make three of a kind.</li>
                </ul>
            </li>
            <li>Check for two pair hands:
                <ul>
                    <li>If there's a pair in the community cards and a pair in your hole cards, you can form two pairs.
                    </li>
                    <li>If there are two distinct community cards that match one each of your hole cards, you can form
                        two pairs.</li>
                    <li>If there's a pair on the board and one card in your hole cards that matches another community
                        card, you can form two pairs.</li>
                </ul>
            </li>

            <li>Check for pair:
                <ul>
                    <li>Identify if there's a single card on the board that matches with a card in your hole cards, or a
                        pair on the board.</li>
                </ul>
            </li>
            <li>Evaluate high cards and kicker strength:
                <ul>
                    <li>If you don't have any strong combinations, pick the highest three cards on the board and the
                        highest two cards in the hole.</li>
                </ul>
            </li>
        </ol>
    </div>


    <div class="card-selection">
        <span class="label">Board:</span>
        <div id="omaha_board"></div>
    </div>
    <div class="card-selection">
        <span class="label">Hole:</span>
        <div id="omaha_hole"></div>
    </div>
    <div id="omaha_score_user"></div>
    <div id="omaha_score_true"></div>
    <!-- Buttons and Timer HTML -->
    <div id="button-container">
        <button id="omahaDrawBtn">New Cards</button>
        <button id="omahaConfirmBtn">Confirm</button>
    </div>
    <div id="timer">
        <span id="minutes">00</span>:<span id="seconds">00</span>
    </div>
    <!-- Create a table to be updated by updateTable -->
    <h2>Results</h2>
    <div class="chart-container">
        <canvas id="performanceChart"></canvas>
    </div>
    <table id="hand_category_table"></table>
    <div id="button-container">
        <button id="ResetStats">Reset Stats</button>
    </div>
</body>

</html>